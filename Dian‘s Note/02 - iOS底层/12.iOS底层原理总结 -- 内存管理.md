# 内存管理

问题：

### 使用CADisplayLink、NSTimer有什么注意点？

- CADisplayLink

  ```objc
  @interface ViewController ()
  @property(nonatomic, strong) CADisplayLink *link;
  @end
  
  @implementation ViewController
  - (void)viewDidLoad {
      [super viewDidLoad];
  	  // 保证调用频率表与屏幕的刷帧率保持一致， 60FPS
      self.link = [CADisplayLink displayLinkWithTarget:self selector:@selector(test)];
      [self.link addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
  }
  - (void)test{
      NSLog(@"%s",__func__);
  }
  - (void)dealloc{
      [self.link invalidate];
  }
  @end
  
  ```

  如上写代码，当我们控制器销毁时 会发现 link定时器 并没有被销毁， 

  vc强引用着link  而link的target有是vc(self)，会产生一个循环引用 

  解决方案与 NStimer第2、3种解决方案一致，

- NSTimer

  ```objc
  
  @interface ViewController ()
  @property(nonatomic, strong) NSTimer *timer;
  @end
  
  @implementation ViewController
  - (void)viewDidLoad {
      [super viewDidLoad];
      self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timeTest) userInfo:nil repeats:YES];
  }
  - (void)timeTest{
      NSLog(@"%s",__func__);
  }
  - (void)dealloc{
      [self.timer invalidate];
  }
  @end
  
  ```

  NSTimer这么些也不会释放

  - 解决方案1：

    - 将Timer换成block形式的,和 __weak typeof(self) weakSelf = self 结合

    ```objective-c
      __weak typeof(self) weakSelf = self;
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {
            [weakSelf timeTest];
        }];
    ///> vc对timer产生强引用， 但是 timer的block对self是弱引用的，所以不会产生强引用
    ```

  - 解决方案2：

    当前timer 的引用如图所示 产生了循环引用， 开率第三者的方式解决

    <img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20191125171246980.png" alt="image-20191125171246980" style="zoom:67%;" />	

    

    我们想办法使用第三者如下图

    <img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20191125171454482.png" alt="image-20191125171454482" style="zoom: 67%;" />

    ```objective-c
    // Proxy.h
    @interface Proxy : NSObject
    + (instancetype)proxyWithTarget:(id)target;
    @property(nonatomic, weak)id target;
    @end
      
    // Proxy.m
    @implementation Proxy
    + (instancetype)proxyWithTarget:(id)target{
        Proxy *pro = [[Proxy alloc]init];
        pro.target = target;
        return pro;
    }
    ///> 消息转发
    - (id)forwardingTargetForSelector:(SEL)aSelector{
        return self.target;
    }
    @end
    //target 是弱引用  利用消息转发机制 将selector的实现交给 target 实现
     // CADisplayuLink 的决绝方案也可以使用这个
    
      
    // ViewController
      // timer
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[Proxy proxyWithTarget:self] selector:@selector(timeTest) userInfo:nil repeats:YES];
    	//link
    self.link = [CADisplayLink displayLinkWithTarget:[Proxy proxyWithTarget:self] selector:@selector(test)];
    ```

  - 解决方案3： 继承自 NSProxy

    这个 直接会走到 消息转发的流程 减少了在消息发送和动态解析的过程 继承自NSProxy的效率会更高一些

    ```objective-c
    @interface Proxyyy : NSProxy   ///> 继承自NSProxy
    + (instancetype)proxyWithTarget:(id)target;
    @property(nonatomic, weak)id target;
    @end
    
    @implementation Proxyyy
    + (instancetype)proxyWithTarget:(id)target{
        // 这个直接使用 alloc 就可以使用了
        Proxyyy *pro = [Proxyyy alloc];
        pro.target = target;
        return pro;
    }
    
    - (NSMethodSignature *)methodSignatureForSelector:(SEL)sel{
        return [self.target methodSignatureForSelector:sel];
    }
    
    - (void)forwardInvocation:(NSInvocation *)invocation{
        [invocation invokeWithTarget:self.target];
        
    }
    @end
    ```

    

### 介绍下内存的几大区域

- iOS程序的内存布局

  <img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20191125190424337.png" alt="image-20191125190424337" style="zoom:50%;" />

### tagged Pointer

- 从64bit开始，iOS引入了Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象的存储
- 在没有使用 tagged Pointer 之前，NSNumber等对象需要动态分配内存，维护引用计数等，NSNumber指针存储的是堆中的NSNumber对象的地址值
- 使用Tagged Pointer 之后 NSNumber指针里面存储了数据变成了 Tag +date，也就是将数据直接存储在了指针中
- 当对象指针的最低有效位是1时，则该指针代表Tagged Pointer ， 在ios平台最高有效位是1 的时候则指针代表Tagged Pointer
- 当指针不够存储数据时，才会使用动态分配内存的方式存储数据
- Objc_msgSend能识别Tagged Pointer , 比如NSNumber的intValue方法，直接从指针提取数据，节省了以前的调用开销。
- 如何判断一个指针是否为 Tagged Pointer呢？
  - iOS平台，最高有效位是 1 （第64bit）
  - Mac平台，最低有效位是1



代码下面两段代码会发生什么事情？

```objc
// 代码1：
dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
for (int i = 0; i< 1000; i++) {
  dispatch_async(queue, ^{
    self.name = [NSString stringWithFormat:@"abcdefghijk"];
  });
}

// 代码2：
dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
for (int i = 0; i< 1000; i++) {
  dispatch_async(queue, ^{
    self.name = [NSString stringWithFormat:@"abcdefghijk"];
  });
}
   
/*
	代码1 会崩溃  ,  因为self.name 的时候是调用了 set方法  set方法中会 有release操作，
				多线程操作 nonatomic 不安全的额 造成了多次的release释放 所以会崩溃 
				
	代码2 不会   字符串使用  taggedpointer技术 将代码直接存在指针中，所以操作的是指针直接复制没有 set、方法  没					有release 所以不会崩溃
	
	*/

NSString *str1 = [NSString StringWithFormat:@"abcdefghijk"];
NSString *str2 = [NSString StringWithFormat:@"abc"];

 NSLog(@"%@ %@",[str1 class], [str2 class]);
/// print:  __NSCFString NSTaggedPointerString   两种类型

NSLog(@"%p  %p", str1, str2);
/// print:  0x600003122000 0xb5c0a1c34d138df3


```



### OC的内存管理

- 在iOS平台中， 使用引用计数来管理OC的内存
- 一个新创建的OC对象的引用计数器默认是1， 当对象的引用计数器为0的时候，对象销毁，释放其占用的内存空间。
- 调用retain会让OC的引用计数器+1，调用release方法会让OC对象的引用计数器-1



- 讲一下你对iOS内存管理的理解
- autorelease在什么时机会被释放
- 方法里有局部对象，出了方法后会立即释放吗？
- ARC都帮我们做了什么
- weak指针的实现原理



