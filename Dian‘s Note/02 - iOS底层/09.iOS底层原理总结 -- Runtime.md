#  iOS底层原理总结 -- Runtime

### Runtime

- Objctive-C是一门动态性比较强的语言，跟C、C++语言有着很大的不同
- Objctive-C的动态性是由Runtime API来支撑的
- Runtime API 提供的接口基本都是C语言的。源码由C\C++\汇编语言组成

### isa详解

- 想要学习Runtime，首先要了解它底层的一些常用数据结构，比如isa指针

- 在arm64构架之前，isa就是一个普通的指针，存储着Class、MetaClass对象的内存地址

- 从arm64构架开始，isa进行了优化，变成了一个共用体（union）结构，还是用了位域来存储更多信息

  ​	<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20191114162203401.png" alt="image-20191114162203401" style="zoom:50%;" /><img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20191114162300694.png" alt="image-20191114162300694" style="zoom: 33%;" />

  ​	union共用体中包含位域

  ```c++
   union isa_t 
  {
      isa_t() { }
      isa_t(uintptr_t value) : bits(value) { }
  
      Class cls;
      uintptr_t bits;   ///>  typedef unsigned long 
  	  struct {
  	      ///> 0 代表普通指针，存储着Class、MetaClass对象的内存地址
          ///> 1 代表优化过，使用位域存储更多信息
          uintptr_t nonpointer        : 1; 
  	      ///> 是否有设置过关联对象，如果没有，释放时会更快
          uintptr_t has_assoc         : 1;
  	      ///> 是否有C++的析构函数（.cxx_destruct）,如果没有，释放会更快
          uintptr_t has_cxx_dtor      : 1;
          ///> 存储着Class、MetaClass的内存地址
          uintptr_t shiftcls          : 33; // MACH_VM_MAX_ADDRESS 0x1000000000
          ///> 用于在调试时分辨率是否未完成初始化
          uintptr_t magic             : 6;
          ///> 是否被弱指针指向过？ 如果没有，释放会更快
          uintptr_t weakly_referenced : 1;
          ///> 对象是否正在释放
          uintptr_t deallocating      : 1;
  			  ///> 引用计数器是否过大？无法存储在isa中
  	      ///> 如果为1，那么引用计数会存储在一个叫 side table的类属性中	
          uintptr_t has_sidetable_rc  : 1;
  				///> 里面存储的值是引用计数器减1
          uintptr_t extra_rc          : 19;
      };
     ...
   }
  ```

   - 什么是共用体？   大家共用一块内存叫共用体 

  - 为什么 类isa 要&ISA_MASK 之后才能过去到元类对象的isa？

    `uintptr_t shiftcls          : 33; // MACH_VM_MAX_ADDRESS 0x1000000000`

    这个就是来存放 cls地址值的

    

  isa在arm64构架之前 isa的值就类对象的地址值。

  isa在arm64构架开始的时候  采用了 isa优化的策略， &上了一个值 isa_mask 使用了共用体的技术。将64位的内存地址存储了很多东西，其中33位存储的是isa具体的地址值的。因为共用体中 前三位有存储的东西，所以在&isa_mask出来的类对象地址值的二进制后面三位永远都是000， 十六进制就是8 或者0结尾的地址值

二进制的使用场景

```objective-c
typedef enum {
    OptOne = 1<<0,   ///> 0b0001
    OptTwo = 1<<1,   ///> 0b0010
    OptThree = 1<<2, ///> 0b0100
    OptFour = 1<<3,  ///> 0b1000
}Opt;
- (void)viewDidLoad {
    [super viewDidLoad];
    [self tset:OptOne|OptTwo|OptFour];
}
- (void)tset:(Opt)opt{
    if (opt & OptOne) {
        NSLog(@"包含了OptOne");
    }
    if (opt & OptTwo) {
        NSLog(@"包含了OptTwo");
    }
    if (opt & OptThree) {
        NSLog(@"包含了OptThree");
    }
    if (opt & OptFour) {
        NSLog(@"包含了OptFour");
    }
}

```



![image-20191111152525825](/Users/yuangonmg/Library/Application Support/typora-user-images/image-20191111152525825.png)





![image-20191115163733518](/Users/yuangonmg/Library/Application Support/typora-user-images/image-20191115163733518.png)





### 方法缓存

- class内部结构中有一个方法缓存（cache_t）用散列表来缓存曾经调用过的方法。可以提高查找的速度

  - 散列表：

  ![image-20191115164318503](/Users/yuangonmg/Library/Application Support/typora-user-images/image-20191115164318503.png)

  当我们调用一个方法的时候

  需要去通过isa指针找到类对象在类对象的bits --> methods -> 查找方法

  每次查找方法的时候都回去遍历，methods是一个二位数组，所以查找的频率会很高， 如果这个类中没有还要去superclass中查找， 如果调用很多次，每次都遍历查找 会很慢的，

  所以在类的objc_class中有一个 cache_t chche的属性存储这方法的缓存

  

  方法缓存的做法：

  第一次调用的时候会将调用的方法放到cache中去， 第二次查找的时候直接冲cache中查找，如果没找到在去methds中查找。

  

  ```c++
  struct cache_t{
  	struct bucket_t *_buckets;  ///> 散列表
    mask_t _mask; ///> 散列表的长度-1
    mask_t _occupied;///>  已经缓存的方法数量
  }
  struct bucket_t{
    cache_key _key; ///>  SEL作为key
    IMP _imp;///>  函数的内存地址
  }
  /*
  _key = @selector(test)
  _imp = test的地址值
  */
  ```

  <img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20191115170753844.png" alt="image-20191115170753844" style="zoom: 50%;" />

  

  当我们将方法存入缓存的时候   他会将@selector(persontest) & _mask = 4 

  然后将这个方法的  bucket_t的结构体存入到 数组的第四个位置， 其他位置留空

  空间换时间。

  

  如果mask的值变化了 就会将缓存清掉重新开始  

  如果碰见一样的了  就-1存储 知道遇见为空的地方， 如果都不为空就放在最后  

  

  ###   objc_msgSend























