[TOC]











1. 编译的原理就是  将多个目标文件合并成一个可执行文件

### Symnol Table

Symnol Table: 符号表，用来保存符号的

String Table：名称符号表，用来保存符号的名称

Indirect Symbol Table: 间接符号表。 保存使用的外部符号。更准确有点就是 使用外部动态库的符号，是Symbol Table的子集

- 间接符号 存储着导出符号 外部动态库的符号
- 全局符号可以理解为是导出符号  导出符号是可以给外接使用的
- OC动态库中 件更不需要暴露的组件 脱离掉

### Weak Symnol 

Weal Reference Symbol: 表示未定义的**弱引用符号**。 如果动态连接器找不到该符号的定义，则将其设置为0 。连接器会将此符号设置弱链接标志

Weak defintion Symbol： 表示此符号为**弱定义符号**，如果静态链接器或动态链接器为此符号找到另一个(非弱)定义，则弱定义将被忽略。只能将合并部分中的符号标记为弱定义



### xcconfig相关命令：

**CMD脚本 命令**

```shell
// TTY 终端的地址  在窗口执行 tty命令即可获得
TTY = /dev/ttys003

// CMD 运行的命令
MACH_PATH = ${BUILD_DIR}/${CONFIGURATION}${EFFECTIVE_PLATFORM_NAME}/${PROJECT_NAME}.app/${PROJECT_NAME}

```

1. 查看__TEXT

   ```shell
   CMD = objdump --macho -d ${MACH_PATH}
   ```

2. 查看符号表

   ```shell
   CMD = objdump --macho --syms ${MACH_PATH}
   ```

3. 查看 Mach header 原始数据

   ```shell
   CMD = otool -h ${MACH_PATH}
   ```

4. 查看 Mach header 解析后数据

   ```shell
   CMD = objdump --macho -private-header ${MACH_PATH}
   ```

5. 查看导出符号

   ```shell
   CMD = objdump --macho --exports-trie ${MACH_PATH}
   ```

6. 查看间接符号表

   ```shell
   CMD = objdump --macho --indirect-symbols ${MACH_PATH}
   ```

7. 

**Symbol相关命令**

1. 不要在输出文件中放置调试信息（STAB或DWARF）。

   ```shell
   OTHER_LDFLAGS = -Xlinker -S
   ```

2. 让你单独的一个导出符号 变为 非导出符号   （可以进一步的减小动态库体积方案）

   ```shell
   OTHER_LDFLAGS = -Xlinker -unexported_symbol -Xlinker _OBJC_METACLASS_$__TtC8iOSMachO14ViewController
   ```

3. map出当前所有使用的 链接库文件信息，section信息  符号信息 

   ```shell
   OTHER_LDFLAGS = -Xlinker -S -Xlinker -map /Users/dian1/Dian_App/iOSMachO/symbol.text
   ```

4. 告诉编译器符号是动态链接的， 在链接阶段 无序报错

   ```shell
   OTHER_LDFLAGS = -Xlinker -U -Xlinker _xxx
   ```

5. aaa 

   ```shell
   ```

6. aaa 

   ```shell
   
   ```

7. aaa 

   ```shell
   
   ```

8. aaa 

   ```shell
   
   ```

9. aaa 

   ```shell
   
   ```

10. aaa 

    ```shell
    
    ```

11. aaa 

    ```shell
    
    ```

12. aaa 

    ```shell
    
    ```

13. 静态库合并

    ```shell
    libtool \
    -static \
    -o \
    libCat.a \
    libAFNetworking.a \
    libSDWebImage.a
    ```



```
objdump 
```



### 静态库生成：

```shell
Last login: Mon Aug 16 17:13:37 on ttys005
➜  ~ cd '/Users/dian1/Desktop/视频/009-Logic iOS 高级强化VIP班/20210120-强化班第三节课：动态库与静态库（上）/静态库/完成代码/静态库原理/StaticLibrary'

➜  StaticLibrary clang -x objective-c \
-target x86_64-apple-macos11.1 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.1.sdk \
-c TestExample.m -o TestExample.o
➜  StaticLibrary file libTestExample
libTestExample: Mach-O 64-bit object x86_64
➜  StaticLibrary cd ../

➜  静态库原理 clang -x objective-c \
-target x86_64-apple-macos11.1 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.1.sdk \
-c test.m -o test.o \
-I ./StaticLibrary

➜  静态库原理 clang -target x86_64-apple-macos11.1 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.1.sdk \
-L./StaticLibrary \
-l TestExample \
test.o -o test

➜  静态库原理 lldb
(lldb) file test
Current executable set to '/Users/dian1/Desktop/视频/009-Logic iOS 高级强化VIP班/20210120-强化班第三节课：动态库与静态库（上）/静态库/完成代码/静态库原理/test' (x86_64).
(lldb) r
Process 93203 launched: '/Users/dian1/Desktop/视频/009-Logic iOS 高级强化VIP班/20210120-强化班第三节课：动态库与静态库（上）/静态库/完成代码/静态库原理/test' (x86_64)
2021-08-17 14:46:39.939045+0800 test[93203:1556803] testApp----
Process 93203 exited with status = 0 (0x00000000)
(lldb) q
```



脚本 

```shell
LANGUAGE=objective-c
TAREGT=x86_64-apple-macos11.1
SYSROOT=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.1.sdk

FILE_NAME=test
STATICLIBRARY=TestExample
HEAD_PATH=./StaticLibrary
LIBRARY_PATH=./StaticLibrary

echo "-------------编译test.m to test.o------------------"
clang -x $LANGUAGE  \
-target $TAREGT     \
-fobjc-arc          \
-isysroot $SYSROOT  \
-I${HEAD_PATH}   \
-c ${FILE_NAME}.m -o ${FILE_NAME}.o

echo "-------------进入到StaticLibrary目录------------------"
pushd ${HEAD_PATH}
echo "-------------编译TestExample.m to TestExample.o------------------"
clang -x $LANGUAGE  \
-target $TAREGT     \
-fobjc-arc          \
-isysroot $SYSROOT  \
-c ${STATICLIBRARY}.m -o ${STATICLIBRARY}.o
echo "-------------退出StaticLibrary目录------------------"

popd

echo "-------------test.o链接libTestExample.a to test EXEC------------------"
clang -target $TAREGT   \
-fobjc-arc              \
-isysroot $SYSROOT      \
-L${LIBRARY_PATH}       \
-l${STATICLIBRARY}           \
$FILE_NAME.o -o $FILE_NAME


```



### mudule

clang 专门处理头文件的解析格式

- 预先将头文件编译成一个二进制  缓存到系统目录中



Auto-Link

链接器的特性，`Auto-Link`。启用这个特性后，当我们`import <模块>`，不需要我们再去往链接器去配置链接参数。比如`import <framework>`我们在代码里使用这个是framework格式的库文件，那么在生成目标文件时，会自动在目标文件的`Mach-O`中，插入一个 `load command`格式是`LC_LINKER_OPTION`，存储这样一个链接器参数`-framework <framework>`。

Framwork:

Mac OS/iOS 平台可以使用Framwork ，实际上它是一种打包的方式  将库的二进制文件，头文件和有关的资源文件打包到一起，方便管理和分发





framwork   

- 静态库 
  - header + .a + 签名 + 资源文件
- 动态库
  - header + .dylib + 签名 + 资源文件





```

/**
 clang命令参数：
     -x: 指定编译文件语言类型
     -g: 生成调试信息
     -c: 生成目标文件，只运行preprocess，compile，assemble，不链接
     -o: 输出文件
     -isysroot: 使用的SDK路径
     1. -I <directory> 在指定目录寻找头文件 header search path
     2. -L <dir> 指定库文件路径（.a\.dylib库文件） library search path
     3. -l <library_name> 指定链接的库文件名称（.a\.dylib库文件）other link flags -lAFNetworking
     -F <directory> 在指定目录寻找framework framework search path
     -framework <framework_name> 指定链接的framework名称 other link flags -framework AFNetworking
 */

/**
    将test.m编译成test.o:
    1. 使用OC
    2. 生成的是X86_64_macOS架构的代码
        Big Sur是：x86_64-apple-macos11.1，之前是：x86_64-apple-macos10.15
    3. 使用ARC
    4. 使用的SDK的路径在：
        Big Sur是：/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.1.sdk
        之前是：/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.15.sdk
    5. 用到的其他库的头文件地址在./Frameworks
 */
clang -x objective-c \
-target x86_64-apple-macos11.1 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.1.sdk \
-I./StaticLibrary \
-c test.m -o test.o


clang -x objective-c \
-target x86_64-apple-macos11.1 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.1.sdk \
-c TestExample.m -o TestExample.o

/**
    test.o链接libTestExample.a生成test可执行文件
    -L./StaticLibrary 在当前目录的子目录StaticLibrary查找需要的库文件
    -lTestExample 链接的名称为libTestExample/TestExample的动态库或者静态库
    查找规则：先找lib+<library_name>的动态库，找不到，再去找lib+<library_name>的静态库，还找不到，就报错
 */
clang -target x86_64-apple-macos11.1 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.1.sdk \
-L./StaticLibrary \
-lTestExample \
test.o -o test

/**
    test.o链接libTestExample.a生成test可执行文件
    -L./StaticLibrary 在当前目录的子目录StaticLibrary查找需要的库文件
    -lTestExample 链接的名称为libTestExample/TestExample的动态库或者静态库
    查找规则：先找lib+<library_name>的动态库，找不到，再去找lib+<library_name>的静态库，还找不到，就报错
    -syslibroot: 系统库文件的目录
 */
ld -syslibroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.1.sdk -lsystem -framework Foundation -lTestExample -L./StaticLibrary test.o -o test


/**
    将test.m编译成test.o:
    1. 使用OC
    2. 生成的是X86_64_macOS架构的代码
        Big Sur是：x86_64-apple-macos11.1，之前是：x86_64-apple-macos10.15
    3. 使用ARC
    4. 使用的SDK的路径在：
        Big Sur是：/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.1.sdk
        之前是：/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.15.sdk
    5. 用到的其他库的头文件地址在./Frameworks/TestExample.framework/Headers
 */
clang -x objective-c  \
-target x86_64-apple-macos11.1 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.1.sdk \
-I./Frameworks/TestExample.framework/Headers \
-c test.m -o test.o


/**
    test.o链接TestExample.framework生成test可执行文件
    -F./Frameworks 在当前目录的子目录Frameworks查找需要的库文件
    -framework TestExample 链接的名称为TestExample.framework的动态库或者静态库
    查找规则：先找TestExample.framework的动态库，找不到，再去找TestExample.framework的静态库，还找不到，就报错
 */
clang -target x86_64-apple-macos11.1 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.1.sdk \
-F./Frameworks \
-framework TestExample \
test.o -o test

clang -x objective-c -fmodules \
-target x86_64-apple-macos11.1 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.1.sdk \
-I./Frameworks/TestExample.framework/Headers \
-c test.m -o test.o

clang -target x86_64-apple-macos11.1 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.1.sdk \
-F./Frameworks \
-framework TestExample \
test.o -o test

/**
 LC_LINKER_OPTION

链接器的特性，`Auto-Link`。启用这个特性后，当我们`import <模块>`，不需要我们再去往链接器去配置链接参数。比如`import <framework>`我们在代码里使用这个是framework格式的库文件，那么在生成目标文件时，会自动在目标文件的`Mach-O`中，插入一个 `load command`格式是`LC_LINKER_OPTION`，存储这样一个链接器参数`-framework <framework>`。
 */

/**
 `ar`压缩目标文件，并对其进行编号和索引，形成静态库。同时也可以解压缩静态库，查看有哪些目标文件：
 ar -rc a.a a.o
    -r: 像a.a添加or替换文件
    -c: 不输出任何信息
    -t: 列出包含的目标文件
 */

/**
    libtool -static -o <OUTPUT NAME> <LIBRARY_1> <LIBRARY_2>
 */

```







```shell

NAME
     ld -- linker

SYNOPSIS
     ld files...  [options] [-o outputfile]

DESCRIPTION
     The ld command combines several object files and libraries, resolves references,
     and produces an output file.  ld can produce a final linked image (executable,
     dylib, or bundle), or with the -r option, produce another object file.  If the -o
     option is not used, the output file produced is named "a.out".

   Universal
     The linker accepts universal (multiple-architecture) input files, but always cre-
     ates a "thin" (single-architecture), standard Mach-O output file.  The architecture
     for the output file is specified using the -arch option.  If this option is not
     used, ld attempts to determine the output architecture by examining the object
     files in command line order.  The first "thin" architecture determines that of the
     output file.  If no input object file is a "thin" file, the native 32-bit architec-
     ture for the host is used.

     Usually, ld is not used directly.  Instead the compiler driver invokes ld. The com-
     piler driver can be passed multiple -arch options and it will create a universal
     final linked image by invoking ld multiple times and then running lipo(1) merge the
     outputs into a universal file.

   Layout
     The object files are loaded in the order in which they are specified on the command
     line.  The segments and the sections in those segments will appear in the output
     file in the order they are encountered in the object files being linked.  All zero
     fill sections will appear after all non-zero fill sections in their segments.  Sec-
     tions created from files with the -sectcreate option will be laid out at after sec-
     tions from .o files. The use of the -order_file option will alter the layout rules
     above, and move the symbols specified to start of their section.

   Libraries
     A static library (aka static archive) is a collection of .o files with a table of
     contents that lists the global symbols in the .o files.  ld will only pull .o files
...skipping...
     -U symbol_name
                 Specified that it is ok for symbol_name to have no definition.  With
                 -two_levelnamespace, the resulting symbol will be marked dynamic_lookup
                 which means dyld will search all loaded images.

     -undefined treatment
                 Specifies how undefined symbols are to be treated. Options are: error,
                 warning, suppress, or dynamic_lookup.  The default is error.

     -rpath path
                 Add path to the runpath search path list for image being created.  At
                 runtime, dyld uses the runpath when searching for dylibs whose load
                 path begins with @rpath/.

     -commons treatment
                 Specifies how commons (aka tentative definitions) are resolved with
                 respect to dylibs.  Options are: ignore_dylibs, use_dylibs, error.  The
                 default is ignore_dylibs which means the linker will turn a tentative
                 definition in an object file into a real definition and not even check
                 dylibs for conflicts.  The dylibs option means the linker should check
                 linked dylibs for definitions and use them to replace tentative defini-
                 tions from object files.  The error option means the linker should
                 issue an error whenever a tentative definition in an object file con-
                 flicts with an external symbol in a linked dylib.  See also -warn_com-
                 mons.

   Options for introspecting the linker
     -why_load   Log why each object file in a static library is loaded. That is, what
                 symbol was needed.  Also called -whyload for compatibility.

     -why_live symbol_name
                 Logs a chain of references to symbol_name.  Only applicable with
                 -dead_strip .  It can help debug why something that you think should be
                 dead strip removed is not removed.  See -exported_symbols_list for syn-
                 tax and use of wildcards.

     -print_statistics
                 Logs information about the amount of memory and time the linker used.

     -t          Logs each file (object, archive, or dylib) the linker loads.  Useful
                 for debugging problems with search paths where the wrong library is
...skipping...
     -S          Do not put debug information (STABS or DWARF) in the output file.

     -x          Do not put non-global symbols in the output file's symbol table. Non-
                 global symbols are useful when debugging and getting symbol names in
                 back traces, but are not used at runtime. If -x is used with -r non-
                 global symbol names are not removed, but instead replaced with a
                 unique, dummy name that will be automatically removed when linked into
                 a final linked image.  This allows dead code stripping, which uses sym-
                 bols to break up code and data, to work properly and provides the secu-
                 rity of having source symbol names removed.

     -non_global_symbols_strip_list filename
                 The specified filename contains a list of non-global symbol names that
                 should be removed from the output file's symbol table.  All other non-
                 global symbol names will remain in the output files symbol table. See
                 -exported_symbols_list for syntax and use of wildcards.

     -non_global_symbols_no_strip_list filename
                 The specified filename contains a list of non-global symbol names that
                 should be remain in the output file's symbol table.  All other symbol
                 names will be removed from the output file's symbol table. See
                 -exported_symbols_list for syntax and use of wildcards.

     -oso_prefix prefix-path
                 When generating the debug map, the linker will remove the specified
                 prefix-path from the path in OSO symbols. This can be used so to help
                 build servers generate identical binaries.

   Options for Bitcode build flow
     -bitcode_bundle
                 Generates an embedded bitcode bundle in the output binary. The bitcode
                 bundle is embedded in __LLVM, __bundle section.  This option requires
                 all the object files, static libraries and user frameworks/dylibs con-
                 tain bitcode.  Note: not all the linker options are supported to use
                 together with -bitcode_bundle.

     -bitcode_hide_symbols
                 Specifies this option together with -bitcode_bundle to hide all non-
                 exported symbols from output bitcode bundle.  The hide symbol process
                 might not be reversible. To obtain a reverse mapping file to recover
                 all the symbols, use -bitcode_symbol_map option.
```















```shell

```

