

### 图像显示原理

CPU处理后的结果是一个bitmap 位图，然后上传给GPU 拿到位图之后做相应的渲染 然后上传到针缓存去中  由视频控制器根据 垂直同步信号提取 缓存区中渲染好的图。



<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9zuhe1zckj31dm0fa435.jpg" alt="image-20191217172502496" style="zoom:33%;" />

UIUview 显示部分由CALayer来负责的   CALayer中有一个contents属性就是  绘制到屏幕上的位图， 经由Core Animation框架提交给GPU的 openGL渲染 进行最重的渲染和纹理和成  然后进行显示





### CPU GPU

CPU:

| Layout   | Display                  | Prepare                             | Commit                  |
| -------- | ------------------------ | ----------------------------------- | ----------------------- |
| UI布局   | 绘制                     | 图片解码                            | 提交位图                |
| 文本计算 | draw方法就发生在这个层级 | 如UIimageView显示直线需要解码的过程 | 由Core Animaton进行提交 |
| 等       |                          |                                     |                         |

GPU:

<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ztpkdvwdj31da0mogq4.jpg" alt="image-20191217165818212" style="zoom: 33%;" />

UI卡顿、掉帧的相关面试题

1. <img src="https://user-gold-cdn.xitu.io/2019/5/13/16ab09457a52fe84?w=1572&amp;h=428&amp;f=png&amp;s=43972" style="zoom: 50%;" />

#### 优化方案：

CPU:

1. 对象的创建  调整  销毁  放到子线程去做
2. 预排版，对于UI的布局计算文本计算  放到子线程去做  主线程就有充足的时间相应用户操作
3. 预渲染，文本的异步绘制，图片的解码  都在子线程操作

GPU

1. 对于纹理的渲染  减少触发离屏渲染，可以依托于CPU的异步绘制机制 减轻GPU的压力
2. 混合视图， 视图层级如果特别复杂的话，混合叠加视图的话，GPU会对每一个视图的合成像素值的合成计算，减轻复杂性会减轻压力 ， 也可以CPU异步绘制 达到 GPU的视图层级少， 就减轻了GPU的压力

### UIView的绘制原理

![image-20191217170958198](https://tva1.sinaimg.cn/large/006tNbRwgy1g9zu1p9or8j311g0kgjwy.jpg)

1. 调用[Uview setNeedsDisplay] 的时候实际上并没有立刻发生当前视图的绘制工作

2. [view.layer setNeedsDisplay],在Runloop快要结束的时候才会开始UI视图的绘制

3. CAlayer display 中首先会判断delegate 是否实现了  displayLayer方法 

   - 如果实现displayLayer方法  - 异步绘制  实现了displayLayer方法

     - 代理负责 生成对象的 bitmap  位图 

     - 设置该bitmap作为layer.contents属性的值

       ![image-20191217185739769](https://tva1.sinaimg.cn/large/006tNbRwgy1g9zx5t0qs3j31do0pqtfk.jpg)

       时序图：、

       - 在调用了 [AsyncDrawingView setNeedsDisply]
       - 在当前runloop快要结束的时候 会由系统调用所对应 layer的display方法 如果实现了 displayLayer这个delegate方法的时候就会实现 displayLayer方法
       - 通过子线程切换去绘制，
         - 通过CGBitmapContextCreat() 是CoreGraphic的一个函数  来创建一个位图的上下文，
         - 通过CoreGraphic API 来做当前UI的绘制工作
         - 通过CGBitmapContextCreatimage() 函数 根据当前所绘制的上下文，生成一张CGImage图片
       - 回到主队列中 通过[CALayer setContents]设置属性  给CAlayer的conntents提交位图

   - 没有实现displayLayer方法  - 系统绘制

     - ![image-20191217171247310](/Users/yuangonmg/Library/Application Support/typora-user-images/image-20191217171247310.png)

     - CALayer内部 会创建一个  backing stor也就是CGContextRef，一般在draw方法中可以通过上下文堆栈取出站定的 context  就是当前视图的上下文

     - layer会判断是够有delegate  

       - 如果没有

         Calayer drawInContext

       - 如果有

         layer.delegate dr Context	然后做当前视图的 绘制工作  

         回调了 [UIView drawRect]方法， 实际上内部什么都没实现， 我们可以根据这个做一些自己的绘制工作

       - 最重都会回到  Calayer uploads backing Store to CPU  就是 最重的位图  结束得了 系统默认的绘制流程

### 离屏渲染

On-Screen Rendering ： 当屏渲染

​	就是在当前显示的屏幕中渲染，值得是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行的

Off-Screen Rendering ： 离屏渲染

​	GPU在当前屏幕缓冲区以外，新开辟了一个缓冲区进行操作的 叫做离屏渲染

#### 什么是离屏渲染？

​	当我们设置UI视图的图层属性时候，如果指令为在被未预合成之前，不能用于直接显示的时候 就触发了离屏渲染比如圆角，遮罩，阴影，光栅化

​	当我们指定了UI视图的某些属性标记为他在未预合成之前不能用于当前屏幕上面直接显示的时候，离屏渲染的概念起源于GPU层面，值得是在当前屏幕路缓冲区以外新开辟一个缓冲区 进行渲染操作。

#### 什么情况下会触发离屏渲染？

1. 设置图层圆角（设置圆角和maskToBounds两个通知设置的时候才会触发） 
2. 图层的蒙版
3. 阴影
4. 光栅化

#### 为何避免离屏渲染？

CPU和GPU在进行视图绘制中做了很多工作 离屏渲染在GPU的层面上出现的，由于离屏渲染使GPU层面触发了openGL的多通道渲染管线，产生了额外的开销

触发离屏渲染的时候会增加GPU的工作量， 如果GPU的工作量增加了， 有可能导致CPU和GPU加起来的总毫秒超过了16.7ms 那么就可能导致UI的卡顿和掉帧。所以要避免离屏渲染。

离屏渲染会创建新的缓冲区，有上下文的切换，所以GPU会有额外的开销。

#### 系统的UI时间传递机制是什么

hittest 和 pointinside的实现

#### UItableView的滚动流畅的方案和思路有什么？

CPU：采用在子线程创建对象的，调整和销毁  预排班 图片的解码  异步绘制的方案

GPU：

#### 什么是离屏渲染？

GUP中如果在当前屏幕缓冲区之外新开辟了一个缓冲区，进行渲染操作就产生了离屏渲染。

IUView和CALayer之间的欢喜

#### UIView专门负责事件传递和事件响应的

CALayer 专门负责显示的工作

为什么区分UIView和CALayer ， 使用了六大设计原则中的单一职责原则。随意要分开处理



## category extension

#### 分了都做了那些事情

1. 私有方法
2. 分解体积庞大类文件，
3. 把Framework的私有方法公开

特点：

1. 在运行时通过Runtime添加到原有类上面
2. 为系统类添加分类，给UIView添加分类，UIbutton等添加分类

分类中都可以添加什么

1. 实例方法
2. 类方法
3. 协议，
4. 属性，如果直接添加只声名了set和get方法的并没有添加实例变量    使用Runtime的关联对象添加就可以添加实例变量了 

extension

​	用扩展声名私有属性、声名私有方法、声名私有成员变量

分类和扩展的区别 

extension： 编译时就决定了、只有声名 、不能为系统的类添加扩展

category： Runtime时候决定了、可以为系统的类添加分类、有声名有实现

### 使用关联对象添加成员变量， 成员变量添加的位置不在本类中，

- 关联对象是由系统提供的  由associatonManager管理并在AssociationHashMap存储

- 通过hash实现的存储在一个全局的容器中， 并不在本类中，不同的分类都放在这个容器当中

  <img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20200106191839583.png" alt="image-20200106191839583" style="zoom:33%;" />



- 是代理模式实现的，注意yongweak修饰注意循环引用，代理一对一
- 通知 NSNotifation使用观察者模式来实现跨层传递消息的机制，是一对多的
- 通知的实现机制，在通知中心可能会维护一个  map表，key为通知的名称，value为observers_list

Kvo Key Value Observer  

- 观察者模式的实现，使用 isa浑写技术实现的
- 系统会在运行时 自动为我们创建一个当前类的子类， 类继承于这个类，对象的isa的指针指向这个子类
- <img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20200107102231107.png" alt="image-20200107102231107" style="zoom:33%;" /><img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20200107102615122.png" alt="image-20200107102615122" style="zoom:33%;" />

- 直接复制成员变量没有办法出发 kvo， 手动实现 在赋值钱添加 willChangeValueForkey 和之后添加 didChangeValueforKey
- 在 didChangeValueForKey 在系统内部当中会出发我们observerValueForKeyPath的方法调用

### kvc

key value coding

​	valueForkey，setValueForKey ，valueForkeyPath

判断是否有和key相关的方法，有直接滴啊用，没有的话判断实例变量是否存在（accessInstanceVariablesDirectly），如果存在直接复制，不存在  调用当前实例的 setvalueforUndefinekey方法 抛出异常

### 属性

- 读写权限  readonly， readwrite（默认）
- 原子:   atomic(复制和获取是线程安全带额  默认关键字   原子属性，但是对数组的操作是不安全带额，atomic只能保证在赋值和获取的时候安全)， nonatomic（非原子性）
- 引用计数： retain、strong、assign、weak 、copy
- assign和weak的区别
  - assign是修饰基本数据类型， 如果修饰对象是不改变引用计数的、修饰对象如果对象释放了指针仍然指向地址野指针导致内存泄漏
  - weak只能修饰对象，weak不改变修饰对象的引用计数，在修饰的对象被释放之后  会自动置位nil







## Runtime

<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20191224174225651.png" alt="image-20191224174225651" style="zoom:33%;" /> 

<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20191224174335713.png" alt="image-20191224174335713" style="zoom:33%;" />





<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20191224174405571.png" alt="image-20191224174405571" style="zoom:33%;" />

<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20191224174438521.png" alt="image-20191224174438521" style="zoom:33%;" />

<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20191224174507846.png" alt="image-20191224174507846" style="zoom:33%;" />

class_rw_t  是二维数组  多存储分类中的方法内容 

<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20191224174605474.png" alt="image-20191224174605474" style="zoom:33%;" />

class_ro_t 是一位数组  存储类的原始方法列表内容

<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20191224174624903.png" alt="image-20191224174624903" style="zoom:33%;" />

method_t 是方法的数据说明

<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20191225102308185.png" alt="image-20191225102308185" style="zoom:33%;" />

函数组成结构简写  type Encodings

<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ganttiid5qj30yo0j2q6p.jpg" alt="image-20200107111539170" style="zoom:33%;" />

Runtime整体数据结构

<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20200107111758493.png" alt="image-20200107111758493" style="zoom:33%;" />

收下 objc_class数据结构（结构体） 继承自objc_objct，objc_objct中有一个成员变量 是isa_t, 指针指向objc_class

objc_class 包含三个成员变量

- superClass指向当前类的父类、class类型指向objc_class
- Cache_t： 缓存方法查找  。 装满了 bucket_t的一个hash表
- class_data_bits_t：表达类的基本信息,   比如 为类定义的 成员、属性方法列表、通过分类所添加的 成员属性方法猎豹等
  - class_rw_t
    - class_ro_t:
      - name、methodList、iVars、properties、protocols
    - methods
    - properties
    - protocols



## isa指向

<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20200107112645376.png" alt="image-20200107112645376" style="zoom:33%;" />

注意： metaClass的isa指针都指向的是 rootClass的MetaClass的   rootClass的isa指针指向的是自己、如果有一个类方法没有实现但是他的实力方法实现了会造成什么后果？    会调用实例方法，因为元类对象的跟类的spuerClass最终指向了实力对像的基类。gangan

### timu

<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20200107113224244.png" alt="image-20200107113224244" style="zoom:33%;" />打印的东西是一样的，都是Mobile， 因为super只是决定了方法的查找位置，接受者是不变的



<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20200107114641326.png" alt="image-20200107114641326" style="zoom:33%;" />1



缓存查找   

<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ganv7isy7qj30si0euacz.jpg" alt="image-20200107120343143" style="zoom:33%;" />

哈希查找、选择器因子和mask做位域操作，得到数组列表中的位置。空间换时间， mask是当前哈希长度-1.  因子是方法地址

第二部： 

当前类中查找   对于已排序好的方法列表，采用二分查找 。对应的执行函数

对没有排序好的列表采用一般遍历查找方式。

<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20200107124606319.png" alt="image-20200107124606319" style="zoom:33%;" />

查找



内存 

<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ganxx9ne6pj30xo0jkgpd.jpg" alt="image-20200107133739460" style="zoom:33%;" />



内存管理方案  

taggedPointer ： NSNumber、小对象等

nonPointer_isa： 64位架构下下  nonPointer_isa  isa

散列表： 包含弱引用表个、引用计数表等。

<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gany2snt9cj31240iw0wr.jpg" alt="image-20200107134258093" style="zoom:33%;" />

<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20200107134455602.png" alt="image-20200107134455602" style="zoom:33%;" />

```objc
union isa_t 
{
    isa_t() { }
    isa_t(uintptr_t value) : bits(value) { }

    Class cls;
    uintptr_t bits;   ///>  typedef unsigned long 
	  struct {
	      ///> 0 代表普通指针，存储着Class、MetaClass对象的内存地址
        ///> 1 代表优化过，使用位域存储更多信息
        uintptr_t nonpointer        : 1; 
	      ///> 是否有设置过关联对象，如果没有，释放时会更快
        uintptr_t has_assoc         : 1;
	      ///> 是否有C++的析构函数（.cxx_destruct）,如果没有，释放会更快
        uintptr_t has_cxx_dtor      : 1;
        ///> 存储着Class、MetaClass的内存地址
        uintptr_t shiftcls          : 33; // MACH_VM_MAX_ADDRESS 0x1000000000
        ///> 用于在调试时分辨率是否未完成初始化
        uintptr_t magic             : 6;
        ///> 是否被弱指针指向过？ 如果没有，释放会更快
        uintptr_t weakly_referenced : 1;
        ///> 对象是否正在释放
        uintptr_t deallocating      : 1;
			  ///> 引用计数器是否过大？无法存储在isa中
	      ///> 如果为1，那么引用计数会存储在一个叫 side table的类属性中	
        uintptr_t has_sidetable_rc  : 1;
				///> 里面存储的值是引用计数器减1
        uintptr_t extra_rc          : 19;
    };
   ...
 }
```



### 散列表方式  

是通过sidetables实现的

<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20200107135255759.png" alt="image-20200107135255759" style="zoom:33%;" />

左侧对象作为一个Key经过hash运算计算出在hash中的索引是什么

eg：  内存指针地址 & 上 hash个数-1  算出来的 索引位置

<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20200107134554532.png" alt="image-20200107134554532" style="zoom:33%;" />



<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20200107134613215.png" alt="image-20200107134613215" style="zoom:33%;" />

为什么 sideTable是多张表而不是一张，如果过多的对象使用一张表加锁解锁效率就会很低。 多张表可以分别加锁分别操作， 不影响效率

sideTable的本质是一张hash表

### 自旋锁

<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20200107143250616.png" alt="image-20200107143250616" style="zoom:33%;" />

### 引用计数表

利用hash表实现的 为了提高查找的效率  避免了for循环的遍历

<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20200107140355142.png" alt="image-20200107140355142" style="zoom:33%;" />

<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20200107143440956.png" alt="image-20200107143440956" style="zoom:33%;" />

### 弱引用表

<img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20200107140726964.png" alt="image-20200107140726964" style="zoom:33%;" />

<img src="https://img-blog.csdn.net/20180920175152461?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNzg0Mzg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述" style="zoom: 50%;" />



ARC :

- 是编译器自动为我们插入retain和release。
- LLVM和Runtime的支持共同协作
- ARC中新增了weak和strong属性关键字
- MRC 手动管理 ARC编译器和Runtime协作自动管理
- MRC中可以调用引用计数相关的方法   ARC中不能调用

引用计数管理

- 实现原理分析：

- alloc ：最重调用了 calloc 此时并没有设置引用计数为1

- retain： Sidetable &table = Sidetables()[this];   table.re  面试：

  <img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20200107144455130.png" alt="image-20200107144455130" style="zoom:33%;" />

  - 在retain的时候系统内部是怎样实现的？
    - 第一次从sidetables找出Sidetable。在通过sidetable的refcnts引用计数map（sidetable中的引用计数表） 也是hash表， 经过了两次hash查找找出他的引用计数在  += SIDE_TABLE_RC_ONE：实际上是4因为size_t中前几位存储的其他的值

- release

  <img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gao000xq8ij312a0ban30.jpg" alt="image-20200107144930066" style="zoom:33%;" />

- RetainCount

  ​	<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gao00ktq2rj311u0duqa7.jpg" alt="image-20200107145002730" style="zoom:33%;" />

- delloc

  ```c++
  objc_object::rootDealloc()
  {
      if (isTaggedPointer()) return;  // fixme necessary
      if (fastpath(isa.nonpointer  &&          // 是 tagged Pointer 优化过的isa指针
                   !isa.weakly_referenced  &&  //   没有弱引用
                   !isa.has_assoc  &&          // 没有关联对象 
                   !isa.has_cxx_dtor  &&       // 没有c++ 构造函数
                   !isa.has_sidetable_rc))     //  没有使用sidetable 存储
      {
          assert(!sidetable_present());
          free(this);   /// 直接释放函数，   如果符合以上这些会释放对象  很快
      } 
      else {
          object_dispose((id)this);  /// 
      }
  }	
  ```

  <img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gao05u5lcpj30ya0k0q7a.jpg" alt="image-20200107145505634" style="zoom:33%;" />

  ```c++
  id 
  object_dispose(id obj)
  {
      if (!obj) return nil;
  
      objc_destructInstance(obj);    
      free(obj);
  
      return nil;
  }
  ```

  

  <img src="/Users/yuangonmg/Library/Application Support/typora-user-images/image-20200107145525025.png" alt="image-20200107145525025" style="zoom:33%;" />

  ```c++
  void *objc_destructInstance(id obj) 
  {
      if (obj) {
          // Read all of the flags at once for performance.
          bool cxx = obj->hasCxxDtor();
          bool assoc = obj->hasAssociatedObjects();
  
          // This order is important.
          if (cxx) object_cxxDestruct(obj);
          if (assoc) _object_remove_assocations(obj);
          obj->clearDeallocating();  /// 将指向当前对象的弱指针清空
      }
  
      return obj;
  }
  ```

  

  ​									Objc_destrictInstance()

<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gao07tefolj30wg0j4gpb.jpg" alt="image-20200107145700088" style="zoom:33%;" />

<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gao0fn5rttj30xw0hs0wt.jpg" alt="image-20200107150430793" style="zoom:33%;" />

弱引用管理 



 