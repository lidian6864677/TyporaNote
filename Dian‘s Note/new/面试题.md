## 事件传递的流程

1. 时间传递分为为两个流程，传递过程和响应过程
   - 传递过程  从UIApplication -> UIwindow  -> 并递归调用所有sunViews通过hitTest和pointInside方法去适合响应的视图  找到后进行响应过程。
   - 响应过程 view -> view ->UIviewController -> UIWindow -> UIAppliication -> UIapplecationDelegate
2. UIbutton 扩大点击范围
   - 重写 pointInside就可以了， CGRectInSet() 可以获取想要的范围  通过CGRectcontentsPoint() 判断 CGPoint是否在 扩大后的范围内
   - 圆形区域同理，判断一个圆形区域
3. 为什么能响应呢？
   - UIview最终都继承与 UIResponse 所以会有 响应

## 分类

1. 分类的实现

- 例如 多个分类添加到宿主类的流程
- 多个分类添加宿主类时 其实是多个分类为一个二位数组 二维数组中存储着二分类的方法列表数组
- 通过attachlists添加到宿主类的  rw_t的methods中
- 由于是倒叙遍历 所以后编译的会分类会优先调用
- 实例方法列表instanceeMethods、类方法列表ClassMethods、协议列表protocols、实例属性列表instanceProperties(只有setget的声明没有实现)同理

2. 分类关联对象的数据结构

   - associateMap 
     - objectAssociateHashMap     objc_address：objctAssociationMap
       - objctAssociationMap      Sel: ObjcAssociation
         - ObjcAssociation : 关联策略

   ```objective-c
   {
     0x123301:{
   		"@selector(title)":{
   			"value": "hello",
   			"policy": "copy"
   			},
       "@selector(type)":{
   			"value": "hello",
   			"policy": "retain"
   			}
     },
       0x123322:{
   		"@selector(text)":{
   			"value": "hello",
   			"policy": "retain"
   			}
     },
   }
   ```

3. 扩展与分类的区别

   - 分类是运行时决议的，扩展式编译时期就决定了
   - 只有声明  实现是在宿主类中实现的
   - 扩展不能为 系统的类进行扩展  分类可以

## 通知的实现

- 通知是一对多的   代理是一对一的  代理注意引用循环
- notifationMap
- notifationMapName: 观察者的信息 及 实现的方法

## KVO

1. 什么是KVO 

   kvo是观察者设计模式的一种实现

   iOS 利用isa-Swizzling  来实现的kvo

2. KVO是怎样实现的？

   - 当我们为一个对象A添加了 addobserver时  其实 系统为我们创建了一个 当前类的子类 命名为 NSKVONotifying_A 
   - NSKVONotifying_A 中 系统实现了 原类的Setter方法 
     - willChangeValueForKey
     - super setvalue
     - didChangeValueForKey (着这个之中会触发系统的kvopath方法)

3. kvc方式能否触发kvo    直接修改成员变量呢？

   kvc是可以的， 成员变量不可以（需要手动添加 willchangeValueorKey  didChangeValueForKey）

## KVC

key-Value coding

## Runtime

1. 方法调用流程

   - 总结来说方法调用三个步骤  消息发送  动态解析  消息转发 如果都未找到则会crash

   - 消息发送

     那对象方法距离  通过对象方法中的isa指针去找到 class对象，class对象中cacheList和class_rw_t中寻找 找到执行。 未找到则去superClass中的cacheList和Class_rw_t中寻找 找到执行并存储对象的cacheList中  未找到则进入动态解析阶段

   - 动态解析

     动态解析则调用 	resolveInstanceMethod:方法进行动态解析 这里边可以动态添加方法class_addMechod执行，并标记为已经执行过动态解析   再次调用send_message步骤 若没有处理则进入消息转发阶段

   - 消息转发

     这个阶段可以分为两种

     一种是 返回一个实现了该方法的对象，通过forwardingTargetForSelector方法

     另一种是 通过 methodSignatureSelector： 创建方法签名 之后走 forwardInvocation去实现相关处理的代码  在forwardInvocation方法中可以做一些安全气垫的相关处理



## aotureleasepool

- autoreleasePool是一个以栈为节点的双向链表，和线程也是一一对应的，所以和runloop也有关系，
- app启动后runloop会注册两个observer 一个是监听即将进入loop   一个是监听即将休眠和退出的，
  - 即将进入loop时会调用 aotureleasepoolpush方法  
  - 休眠调用aotureleaseePop方法和aotureleasepoolpush  释放旧的创建新的
  - 退出时 会调用 aotureleaseePop 释放
- push: 创建哨兵对象，添加
- pop： 释放到传入的哨兵对象位置。

​    autoreleasePool栈为节点的双向链表，有手动和runloop两种 手动释放为大括号结束，runloop由 即将进入loop添加对象，添加位置由next指针决定，休眠和退出两个节点释放对象。释放位置有哨兵对象决定





启动优化

main函数之前

- dylib 动态库链接  打包的时候动态库的包比静态库的包大
- rebase binding 动态库绑定
- objc  类注册    2万个类 大概增加800ms时间
- Initalizer  构造函数  load耗时
- 

OC换swift效率更高

- 最直观的是业务层面的优化、
- 二进制重排 - 内存分配
  - 因为目前虚拟内存概念的  每个进程都会有自己的虚拟内存 在通过一张映射表才能获取真实的物理地址  在使用的时候加载到物理内存中  
  - 应用启动时以懒加载的方式加载到内存中，使用多少加载多少，因为虚拟内存中是以映射表的方式存在的 你不能保证你所有启动需要的函数都会在一个page中所以会产生切换page的情况 缺页中断 page fault情况 每一次page fault都会签名验证 一个很少但是多的二时候就不容小觑了
  - 二进制重排就是为了解决 过多的page fault应运而生的
  - 查看page fault次数 使用 system trace可查看  添加 DYLD_PRINT_STATISTICS‘
  - 利用linkMap 查看是否修改成功’ 默认是 根据compile source 顺序决定的
  - 



Source1 基于port的内核时间 系统事件源 主动唤醒runloop

- 字典存储   key machport:source1 

source0 不能主动出发时间 需要手动wakeuo唤醒

## 启动速度

要从三个角度出发

1. main函数之前
   1. dyld动态库的链接   images类的加载，分类的加载 C++ +load
   2. 从这几个角度去 减少类分类及+load的使用
   3. 这里也可以使用二进制重拍的方案
   4. 因为在类启动函数中 会涉及到类加载问题 这会涉及到一些虚拟内存 和 断页的问题 所以利用CLang插装获取启动需要用到类   指定.order文件 进行重新排序避免 断页过多问题
2. main函数之后
   1. 业务逻辑   延后  部分三方库的注册，配置接口请求，按需加载  

## 包大小

1. 受益最大的就是  图片的无损压缩 这里有两个方案  一个是webp 一个是 熊猫

## 途家

1. 体现能力的点
2. 锁的使用 
3. 多线程的应用
4. https 建立流程
5. 接口加密   防抓包
6. http1.0和2.0的区别
7. 判断一个单向链表是否是  abba格式的。

1. 



