```objective-c
// 代码1：
dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
for (int i = 0; i< 1000; i++) {
  dispatch_async(queue, ^{
    self.name = [NSString stringWithFormat:@"abcdefghijk"];
  });
}

// 代码2：
dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
for (int i = 0; i< 1000; i++) {
  dispatch_async(queue, ^{
    self.name = [NSString stringWithFormat:@"abcd"];
  });
}















/// Student继承于Person
Student：Person   
- (instancetype)init{
    self = [super init];
    if (self) {
        NSLog(@"[self class]       = %@", [self class]); 		  
        NSLog(@"[self superclass]  = %@", [self superclass]); 
        NSLog(@"[super class]      = %@", [super class]);		  
        NSLog(@"[super superclass] = %@", [super superclass]);
    }
    return self;
}














- (void)test{
    NSLog(@"%@  任务1", [NSThread currentThread]);
    dispatch_queue_t queue = dispatch_queue_create("myqueue", DISPATCH_QUEUE_SERIAL);
    dispatch_async(queue, ^{
        NSLog(@"%@  任务2", [NSThread currentThread]);
        dispatch_sync(queue, ^{	
            NSLog(@"%@  任务3", [NSThread currentThread]);
        });
        NSLog(@"%@  任务4", [NSThread currentThread]);
    });
    NSLog(@"%@  任务5", [NSThread currentThread]); 
}



















///> 代码1：
- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0 );
    dispatch_async(queue, ^{
				NSLog(@"%@    1",[NSThread currentThread]);
        [self performSelector:@selector(test) withObject:nil afterDelay:.0];
        NSLog(@"%@    2",[NSThread currentThread]);
    });
}
- (void)test{
    NSLog(@"%@    3",[NSThread currentThread]);
}









///> 代码2：
- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0 );
    dispatch_async(queue, ^{
        NSLog(@"%@    1",[NSThread currentThread]);
        [self performSelector:@selector(test) withObject:nil];
        NSLog(@"%@    2",[NSThread currentThread]);
    });
}
- (void)test{
    NSLog(@"%@    3",[NSThread currentThread]);
}









```

































































基础

1. 想要一个属性 实现对外只读  对内读写怎么办？
2. 分类的实现原理   如果多个分类同一个方法的会优先加载哪一个 调用顺序由什么决定的
3. 设计一个图片下载的逻辑框架？ 考虑的因素等...
4. UIButton连点  扩大点击范围

- 属性的修饰词都有什么？

- nonatomic：非原子性

  被nonatomic修饰的属性可以多线程同时访问，没有现成的限制，是不安全的访问，但是效率高

- atomic：原子性

  Atomic 只保证09876409876098709876400978640987644440987098760098764800089708970807896089为私有属性，外部暴露的方法调用的时候进行加锁处理 来保证线程的安全。

  建议使用  信号量。

- 
- copy和mutablecopy   mucopy copy了一个数组 数组里面是对象的话 里面的对象会被copy吗？ 对象的copy
- weak指针的实现原理
- 分类的实现原理   如果多个分类同一个方法的会优先加载哪一个 调用顺序由什么决定的
- 消息发送的流程

常见的多线程方案

ios中的线程同步方案

异步并发执行任务1，任务2，执行完之后在执行任务3   dispatch_group_notify

​	

- GCD更偏向于底层  NSOperation更偏向于抽象， NSOperation是基于GCD实现的。
- 对于异步操作的执行顺序，依赖关系，事务性，GCD更为复杂，NSOperation已经实现好了
- 底层之间依赖关系不大，需要更高的并发能力，GCD更优优势

属性的各种修饰词

- nonatomic和atomic的区别
  - nonatomic非原子性  非安全的  可以任意操作
  - atomic原子性  安全的  值局限于seter和geter45



为什么 View不能点击但是button可以



属性和实例变量的区别

分类

UIView和Calayer的区别

3454352605260620000092035666200435620000056262

Block怎么捕获的外部变量

​                             frame和bounds的区别? 为什么有了frame还要有bounds呢？

利用View获取控制器。响应链 。   UIapplication的上一层是什么？

assign和weak的区别

被weak修饰的对象的内部结构

UI响应链问题：两个button重叠放在一起  哪一个会响应， 如果上面的用户可交互是禁止的呢？ 哪一个会响应？

String用copy  和NSMutableDictionary，NSMutableArray 用copy	

http和https的区别 

启动流程

ViewController声明周期

设计一个图片下载的逻辑框架？ 考虑的因素等...

UI响应链问题：两个button重叠放在一起  哪一个会响应， 如果上面的用户可交互是禁止的呢？ 哪一个会响应？

runtime 方法的调用流程  实际应用











### 0. 这几个NSString创建的有什么区别？

考察点， 对iOS底层 优化的理解  taggedPointer， 内存的分配情况

```objc
    NSString *str1 = @"a";                                          //0x1049cc248
    NSString *str2 = [NSString stringWithFormat:@"a"];              //0xa000000000000611
    NSString *str3 = [NSString stringWithFormat:@"bccd"];           //0xa000000646363624
    NSString *str4 = [NSString stringWithFormat:@"c"];              //0xa000000000000631
    NSString *str5 = [NSString stringWithFormat:@"cdasjkfsdljfiwejdsjdlajfl"];//0x1c02418f0
```

#### 1. 这段代码有什么问题？

考察点：autoreleasepool的释放时机， 1. runloop中释放 和 自己写一份释放的区别和时机

```rust
for (int i = 0; i < 10000; ++i) { 
    NSString *str = @"Abc"; 
    str = [str lowercaseString]; 
    str = [str stringByAppendingString:@"xyz"];
    NSLog(@"%@", str); 
 }


//答案：、、 和Runloop有关， 内存没有得到及时的释放
for (int i = 0; i < 10000; ++i) { 
    @autoreleasepool { 
        NSString *str = @"Abc"; 
        str = [str lowercaseString];
        str = [str stringByAppendingString:@"xyz"]; 
        NSLog(@"%@", str);
     } 
}
```

#### 2. 代码输出内容  

​	考察点  tagedPointer    __weak修饰符的理解

```objc
__weak NSNumber *weakNumber;
__weak NSString *weakString;
__weak NSDate *weakDate;
__weak NSObject *weakObj;
int num = 123;

@autoreleasepool {
    weakObj = [[NSObject alloc] init];
    weakNumber = [NSNumber numberWithInt:num];
    weakString = [NSString stringWithFormat:@"string%d", num];
    weakDate   = [NSDate dateWithTimeIntervalSince1970:0];
}
NSLog(@"weakObj is %@", weakObj);
NSLog(@"weakNumber is %@", weakNumber);
NSLog(@"weakString is %@", weakString);
NSLog(@"weakDate is %@", weakDate);

/**
 * weakObj is Null
 * weakNumber is 123
 * weakString is string123
 * weakDate is Thu Jan 1 08:00:00 1970
 */
```

#### 3.算法题：

```objc
/**
1. [1,2,5,10] 几种硬币，给定一个数值m求最少用多少硬币怎么组合可以拿到
2. 扩展 有多少种组合方式
*/
1. 逆序遍历求余和值。
  
2. 18元/5 = 3..3
  遍历3210
  依次了类推



```







 杨璐凯  iOS技术方面还行 对于问题回答的比较含糊  缺少总结和自己的思考

网络和算法方面欠缺





杨璐凯： iOS 方面技术不错，待定。 

赵鹏： 对工作的态度不是很积极，思想比较固化。 暂时待定

刘向文：技术不合格  pass

李二洋：

```
李二洋：技术一般，经验不足 pass
熊保奎：技术可以， 待定
马中辉：技术一般，对之前做的语聊项目了解的特别少  pass
贾綮员：技术不合格  pass
李自豪：技术一般 项目经验不足  pass
https://a.app.qq.com/o/simple.jsp?pkgname=com.coolpi.mutter&g_f=1000047
https://down2.cudown.com/app/nannanchucp.apk
郭兴松：技术一般，相比较 房淼瑞差很多， pass
房淼瑞：技术可以  暂时待定。

```













